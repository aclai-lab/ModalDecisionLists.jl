Main:

    Generic:
        ☐ Eliminare implementazione superflua cn2
            ✔ arrivare a due implementazioni uguali @done(24-04-03 11:05)
                ✔ sole_cn2 as orange_cn2(simple selector version) @done(24-03-14 20:39)
                ✔ base_cn2 as orange_cn2(simple selector version) @done(24-03-16 12:00)

        ☐ new section in docu
        ☐ MLJ interface for cn2
        ✔ Aggiornare confronto tra LmCF @done(24-03-04 19:36)
        # (rimuovere confronto tramite Base.:(==))
        ☐ Laplace
        ☐ entropyMDL
        ☐ Rule validation
        ☐ LRS
        ☐ Weighted relative accuracy
    
    Utility:
        ✔ Implementing instances(PropositionalLogiset) @done(24-03-04 17:11)
            ✔ Gestione errore in istanziazione PropositionalLogiset{DataFrame}(SubDataFrame) @done(24-03-04 17:11)
            # già scritta soluzione temporanea
        ✔ add alphabet parameter @done(24-04-03 11:06)
        ✔ check empty row table in ProposiionlLogiset costruction @done(24-04-03 17:35)
        ✔ map from integer to original class names @done(24-04-10 16:31)
        ☐ semplificazione LmCF o LmDF 
            # scalarminimizer
        ✔ BoundedScalarCond -> UnivariateScalarCondion @done(24-04-10 16:31)
        ☐ Aggiungere operazioni di pulizia del dataset prima di usarlo come training-dataset.
            # Rimuovere istanze duplicate
                # Istanze duplicate con classe UGUALE. 
                # istamze duplicate con classe DIVERSA
            # gestione missing values  
    
    Testing:
        ✔ Verificare 100% accuratezza sul dataset di trainig ? @done(24-03-01 03:02)
        ☐ Test accuratezza
            ☐ Only real attributes
                ☐ Xy = RDatasets.dataset("psych", "sat.act")
                ☐ Xy = RDatasets.dataset("gamair", "wesdr")
                ☐ Xy = RDatasets.dataset("gamair", "wesdr")
                ☐ Xy = RDatasets.dataset("ISLR", "Weekly")     Too large
                ☐ Xy = RDatasets.dataset("ISLR", "OJ")
                ☐ Xy = RDatasets.dataset("ISLR", "Caravan")
                ☐ Xy = RDatasets.dataset("ISLR", "Smarket")
                ☐ Xy = RDatasets.dataset("ISLR", "Default")
                ☐ Xy = RDatasets.dataset("Ecdat", "BudgetFood")
            ☐ With categorical real attributes
                ☐ Xy = RDatasets.dataset("mlmRev", "Early")
                ☐ Xy = RDatasets.dataset("mlmRev", "Contraception")
                ☐ Xy = RDatasets.dataset("mlmRev", "guPrenat")
                ☐ Xy = RDatasets.dataset("survival", "logan")
            
    Future: 
        ✔ Differenziare caso attributi discreti/categoriali
        ☐ Aggiungere campo supporting_labels (vettore)
        # Vettore delle labels delle istanze su cui la regola è costruita (ovvero, quelle che non sono coperte dalle regole precedenti), e nel 
        # info del constant model ci metti un campo supp_labels con le labels delle istanze che, tra queste, sono coperte dalla regola. 
        ☐ Aggiungere campo predicted_labels (forse)
        # labels predette dal modello, ma in principio le support_labels sono sufficienti 
        # per calcolare diverse metriche 
    

    MLJ-Interface:
        ✔ Constructor with keyword arguments @done(24-04-12 13:32)
        ☐ fit
            # parlare con gio di CategoricalArrays
        ☐ predict
        ☐ clean!
            # https://juliaai.github.io/MLJModelInterface.jl/dev/quick_start_guide/
        ☐ MMI.metadata_pkgMMI.metadata_pkg