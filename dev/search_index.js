var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ModalDecisionLists","category":"page"},{"location":"#ModalDecisionLists","page":"Home","title":"ModalDecisionLists","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for ModalDecisionLists.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ModalDecisionLists, ModalDecisionLists.MLJInterface, ModalDecisionLists.experimentals]","category":"page"},{"location":"#TODO-continue-this-example","page":"Home","title":"TODO continue this example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"sequentialcovering\nSearchMethod\nAtomSearch\nBeamSearch\nRandSearch","category":"page"},{"location":"#ModalDecisionLists.sequentialcovering","page":"Home","title":"ModalDecisionLists.sequentialcovering","text":"function sequentialcovering(\n    X::AbstractLogiset,\n    y::AbstractVector{<:CLabel},\n    w::Union{Nothing,AbstractVector{U},Symbol} = default_weights(length(y));\n    kwargs...\n)::DecisionList where {U<:Real}\n\nLearn a decision list on an logiset X with labels y and weights w following the classic sequential covering learning scheme. This involves iteratively learning a single rule, and removing the newly covered instances.\n\nKeyword Arguments\n\nsearchmethod::SearchMethod: The search method for finding single rules (see SearchMethod);\nmax_rulebase_length::Union{Nothing,Integer} is the maximum length of the rulebase;\nsuppress_parity_warning::Bool if true, suppresses parity warnings.\nunorderedstrategy::Bool: TODO @Edo explain\nmin_rule_coverage::Integer:\nAny additional keyword argument will be imputed to the searchmethod, replacing its original value.\n\nExamples\n\n\njulia> X = PropositionalLogiset(iris_dataframe);\n\njulia> y = Vector{CLabel}(iris_labels);\n\njulia> sequentialcovering(X, y)\n▣\n├[1/22]┐(:sepal_length ≤ 4.8)\n│└ setosa\n├[2/22]┐(:sepal_length ≥ 7.1)\n│└ virginica\n├[3/22]┐(:sepal_length ≥ 7.0)\n│└ versicolor\n├[4/22]┐(:sepal_width ≤ 2.0)\n│└ versicolor\n├[5/22]┐(:sepal_width ≥ 3.5)\n│└ setosa\n├[6/22]┐(:petal_length ≤ 1.7)\n│└ setosa\n├[7/22]┐(:petal_length ≤ 4.4)\n│└ versicolor\n├[8/22]┐(:sepal_length ≤ 4.9)\n│└ virginica\n├[9/22]┐(:sepal_length ≤ 5.4)\n│└ versicolor\n├[10/22]┐(:petal_length ≤ 4.7)\n│└ versicolor\n├[11/22]┐(:sepal_length ≤ 5.8)\n│└ virginica\n├[12/22]┐(:sepal_width ≤ 2.2)\n│└ virginica\n├[13/22]┐(:sepal_width ≥ 3.3)\n│└ virginica\n├[14/22]┐(:petal_length ≥ 5.2)\n│└ virginica\n├[15/22]┐(:petal_width ≤ 1.4)\n│└ versicolor\n├[16/22]┐(:petal_width ≥ 1.9)\n│└ virginica\n├[17/22]┐(:sepal_length ≥ 6.7)\n│└ versicolor\n├[18/22]┐(:sepal_width ≤ 2.5)\n│└ versicolor\n├[19/22]┐(:sepal_length ≥ 6.1)\n│└ virginica\n├[20/22]┐(:sepal_width ≤ 2.7)\n│└ versicolor\n├[21/22]┐(:sepal_length ≥ 6.0)\n│└ virginica\n├[22/22]┐(:sepal_width ≤ 3.0)\n│└ virginica\n└✘ versicolor\n\nSee also SearchMethod, BeamSearch, PropositionalLogiset, DecisionList.\n\n\n\n\n\n","category":"function"},{"location":"#ModalDecisionLists.SearchMethod","page":"Home","title":"ModalDecisionLists.SearchMethod","text":"    SearchMethod\n\nAbstract type for all search methods to be used in sequentialcovering.\n\nAny search method implements a findbestantecedent method.\n\nSee also findbestantecedent, BeamSearch, RandSearch.\n\n\n\n\n\n","category":"type"}]
}
